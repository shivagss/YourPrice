/*
 * AVIARY API TERMS OF USE
 * Full Legal Agreement
 * The following terms and conditions and the terms and conditions at
 * http://www.aviary.com/terms (collectively, the ���Terms���) govern your use
 * of any and all data, text, software, tools, documents and other materials
 * associated with the application programming interface offered by Aviary, Inc.
 * (the "API"). By clicking on the ���Accept��� button, OR BY USING OR ACCESSING
 * ANY PORTION OF THE API, you or the entity or company that you represent are
 * unconditionally agreeing to be bound by the terms, including those available
 * by hyperlink from within this document, and are becoming a party to the
 * Terms. Your continued use of the API shall also constitute assent to the
 * Terms. If you do not unconditionally agree to all of the Terms, DO NOT USE OR
 * ACCESS ANY PORTION OF THE API. If the terms set out herein are considered an
 * offer, acceptance is expressly limited to these terms. IF YOU DO NOT AGREE TO
 * THE TERMS, YOU MAY NOT USE THE API, IN WHOLE OR IN PART.
 * 
 * Human-Friendly Summary
 * If you use the API, you automatically agree to these Terms of Service. Don't
 * use our API if you don't agree with this document!
 * 1. GRANT OF LICENSE.
 * Subject to your ("Licensee") full compliance with all of Terms of this
 * agreement ("Agreement"), Aviary, Inc. ("Aviary") grants Licensee a
 * non-exclusive, revocable, nonsublicensable, nontransferable license to
 * download and use the API solely to embed a launchable Aviary application
 * within Licensee���s mobile or website application (���App���) and to access
 * data from Aviary in connection with such application. Licensee may not
 * install or use the API for any other purpose without Aviary's prior written
 * consent.
 * 
 * Licensee shall not use the API in connection with or to promote any products,
 * services, or materials that constitute, promote or are used primarily for the
 * purpose of dealing in: spyware, adware, or other malicious programs or code,
 * counterfeit goods, items subject to U.S. embargo, unsolicited mass
 * distribution of email ("spam"), multi-level marketing proposals, hate
 * materials, hacking/surveillance/interception/descrambling equipment,
 * libelous, defamatory, obscene, pornographic, abusive or otherwise offensive
 * content, prostitution, body parts and bodily fluids, stolen products and
 * items used for theft, fireworks, explosives, and hazardous materials,
 * government IDs, police items, gambling, professional services regulated by
 * state licensing regimes, non-transferable items such as airline tickets or
 * event tickets, weapons and accessories.
 * 
 * Use Aviary the way it's intended (as a photo-enhancement service), or get our
 * permission first.
 * If your service does anything illegal or potentially offensive, we don't want
 * Aviary to be in your app. Nothing personal - it just reflects badly on our
 * brand.
 * 2. BRANDING.
 * Licensee agrees to the following: (a) on every App page that makes use of the
 * Aviary API, Licensee shall display an Aviary logo crediting Aviary only in
 * accordance with the branding instructions available at
 * [www.aviary.com/branding]; (b) it shall maintain a clickable link to the
 * following location [www.aviary.com/api-info], prominently in the licensee App
 * whenever the API is displayed to the end user. (c) it may not otherwise use
 * the Aviary logo without specific written permission from Aviary; and (d) any
 * use of the Aviary logo on an App page shall be less prominent than the logo
 * or mark that primarily describes the Licensee website, and Licensee���s use
 * of the Aviary logo shall not imply any endorsement of the Licensee website by
 * Aviary.
 * 
 * (a) Don't remove or obscure the Aviary logo in the editor.
 * (b) Don't remove or obscure the link to Aviary's mobile info. We link the
 * Aviary logo to this info so you don't need to add anything extra to your app.
 * (c) We're probably cool with you using our logo as part of a press release
 * announcing our editor or otherwise promoting your use of Aviary. Just please
 * ask us first. :)
 * (d) Please make sure that your users aren't confused as to who made your app
 * by always keeping your logo more prominent than ours. You did most of the
 * hard work for your app and should get all of the credit. :)
 * 3. PROPRIETARY RIGHTS.
 * As between Aviary and Licensee, the API and all intellectual property rights
 * in and to the API are and shall at all times remain the sole and exclusive
 * property of Aviary and are protected by applicable intellectual property laws
 * and treaties. Except for the limited license expressly granted herein, no
 * other license is granted, no other use is permitted and Aviary (and its
 * licensors) shall retain all right, title and interest in and to the API and
 * the Aviary logos.
 * 
 * Aviary owns all of the rights in the API it is allowing you to use. Our
 * allowance of you to use it, does not mean we are transferring ownership to
 * you.
 * 4. OTHER RESTRICTIONS.
 * Except as expressly and unambiguously authorized under this Agreement,
 * Licensee may not (i) copy, rent, lease, sell, transfer, assign, sublicense,
 * disassemble, reverse engineer or decompile (except to the limited extent
 * expressly authorized by applicable statutory law), modify or alter any part
 * of the API; (ii) otherwise use the API on behalf of any third party.
 * 
 * (i) Please don't break our API down and redistribute it without our consent.
 * (ii) Please don't agree to use our API if you are not the party using it. If
 * you are a developer building the API into a third party app, please have your
 * client review these terms, as they have to agree to them before they can use
 * the API.
 * 5. MODIFICATIONS TO THIS AGREEMENT.
 * Aviary reserves the right, in its sole discretion to modify this Agreement at
 * any time by posting a notice to Aviary.com. You shall be responsible for
 * reviewing and becoming familiar with any such modification. Such
 * modifications are effective upon first posting or notification and use of the
 * Aviary API by Licensee following any such notification constitutes
 * Licensee���s acceptance of the terms and conditions of this Agreement as
 * modified.
 * 
 * We may update this agreement from time to time, as needed. We don't
 * anticipate any major changes, just tweaks to the legalese to reflect any new
 * feature updates or material changes to how the API is offered. While we will
 * make a good faith effort to notify everyone when these terms update with
 * posts on our blog, etc... it's your responsibility to keep up-to-date with
 * these terms on a regular basis. We'll post the last-update date at the bottom
 * of the agreement to make it easier to know if the terms have changed.
 * 6. WARRANTY DISCLAIMER.
 * THE API IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. EXCEPT TO THE
 * EXTENT REQUIRED BY APPLICABLE LAW, AVIARY AND ITS VENDORS EACH DISCLAIM ALL
 * WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, REGARDING THE API,
 * INCLUDING WITHOUT LIMITATION ANY AND ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY, ACCURACY, RESULTS OF USE, RELIABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, TITLE, INTERFERENCE WITH QUIET ENJOYMENT, AND
 * NON-INFRINGEMENT OF THIRD-PARTY RIGHTS. FURTHER, AVIARY DISCLAIMS ANY
 * WARRANTY THAT LICENSEE'S USE OF THE API WILL BE UNINTERRUPTED OR ERROR FREE.
 * 
 * Things might break. Hopefully not and if so, we'll do our best to fix it
 * immediately. But if it happens, please note that we aren't responsible. You
 * are using the API "as is" and understand the risk inherent in that.
 * 7. SUPPORT AND UPGRADES.
 * This Agreement does not entitle Licensee to any support and/or upgrades for
 * the APIs, unless Licensee makes separate arrangements with Aviary and pays
 * all fees associated with such support. Any such support and/or upgrades
 * provided by Aviary shall be subject to the terms of this Agreement as
 * modified by the associated support Agreement.
 * 
 * We can't promise to offer any kind of support or future upgrades. We plan to
 * help all of our partners to the best of our ability, but use of our API
 * doesn't entitle you to this.
 * 8. LIABILITY LIMITATION.
 * REGARDLESS OF WHETHER ANY REMEDY SET FORTH HEREIN FAILS OF ITS ESSENTIAL
 * PURPOSE OR OTHERWISE, AND EXCEPT FOR BODILY INJURY, IN NO EVENT WILL AVIARY
 * OR ITS VENDORS, BE LIABLE TO LICENSEE OR TO ANY THIRD PARTY UNDER ANY TORT,
 * CONTRACT, NEGLIGENCE, STRICT LIABILITY OR OTHER LEGAL OR EQUITABLE THEORY FOR
 * ANY LOST PROFITS, LOST OR CORRUPTED DATA, COMPUTER FAILURE OR MALFUNCTION,
 * INTERRUPTION OF BUSINESS, OR OTHER SPECIAL, INDIRECT, INCIDENTAL OR
 * CONSEQUENTIAL DAMAGES OF ANY KIND ARISING OUT OF THE USE OR INABILITY TO USE
 * THE API, EVEN IF AVIARY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH LOSS OR
 * DAMAGES AND WHETHER OR NOT SUCH LOSS OR DAMAGES ARE FORESEEABLE. ANY CLAIM
 * ARISING OUT OF OR RELATING TO THIS AGREEMENT MUST BE BROUGHT WITHIN ONE (1)
 * YEAR AFTER THE OCCURRENCE OF THE EVENT GIVING RISE TO SUCH CLAIM. IN
 * ADDITION, AVIARY DISCLAIMS ALL LIABILITY OF ANY KIND OF AVIARY'S VENDORS.
 * 
 * Want to sue us anyway? That's cool (really not), but you only have a year to
 * do it. Better act quick, Perry Mason.
 * 9. INDEMNITY.
 * Licensee agrees that Aviary shall have no liability whatsoever for any use
 * Licensee makes of the API. Licensee shall indemnify and hold harmless Aviary
 * from any and all claims, damages, liabilities, costs and fees (including
 * reasonable attorneys' fees) arising from Licensee's use of the API.
 * 
 * You acknowledge that we aren't responsible at all, for anything that happens
 * resulting from your use of our API.
 * 10. TERM AND TERMINATION.
 * This Agreement shall continue until terminated as set forth in this Section.
 * Either party may terminate this Agreement at any time, for any reason, or for
 * no reason including, but not limited to, if Licensee violates any provision
 * of this Agreement. Any termination of this Agreement shall also terminate the
 * license granted hereunder. Upon termination of this Agreement for any reason,
 * Licensee shall destroy and remove from all computers, hard drives, networks,
 * and other storage media all copies of the API, and shall so certify to Aviary
 * that such actions have occurred. Aviary shall have the right to inspect and
 * audit Licensee's facilities to confirm the foregoing. Sections 3 through 11
 * and all accrued rights to payment shall survive termination of this
 * Agreement.
 * 
 * We can revoke your license (and you can choose to end your license) at any
 * time, for any reason. We won't take this lightly, but we do hold onto this
 * right should it be needed.
 * If either party terminates this license, you will need to remove the Aviary
 * API from your code entirely. We'll have the right to double-check to make
 * sure you have.
 * Terminating the agreement ends your ability to use our App. It doesn't change
 * some of the other sections (namely 3-11).
 * 11. GOVERNMENT USE.
 * If Licensee is part of an agency, department, or other entity of the United
 * States Government ("Government"), the use, duplication, reproduction,
 * release, modification, disclosure or transfer of the API are restricted in
 * accordance with the Federal Acquisition Regulations as applied to civilian
 * agencies and the Defense Federal Acquisition Regulation Supplement as applied
 * to military agencies. The API are a "commercial item,"
 * "commercial computer software" and
 * "commercial computer software documentation." In accordance with such
 * provisions, any use of the API by the Government shall be governed solely by
 * the terms of this Agreement.
 * 
 * Work for the government? Here is some special legalese just for you.
 * 12. EXPORT CONTROLS.
 * Licensee shall comply with all export laws and restrictions and regulations
 * of the Department of Commerce, the United States Department of Treasury
 * Office of Foreign Assets Control ("OFAC"), or other United States or foreign
 * agency or authority, and Licensee shall not export, or allow the export or
 * re-export of the API in violation of any such restrictions, laws or
 * regulations. By downloading or using the API, Licensee agrees to the
 * foregoing and represents and warrants that Licensee is not located in, under
 * the control of, or a national or resident of any restricted country.
 * 
 * To any potential partner located in a country with whom it is illegal for the
 * USA to do business: We're genuinely sorry our governments are being jerks to
 * each other and look forward to the day when it isn't illegal for us to do
 * business together.
 * 13. MISCELLANEOUS.
 * Unless the parties have entered into a written amendment to this agreement
 * that is signed by both parties regarding the Aviary API, this Agreement
 * constitutes the entire agreement between Licensee and Aviary pertaining to
 * the subject matter hereof, and supersedes any and all written or oral
 * agreements with respect to such subject matter. This Agreement, and any
 * disputes arising from or relating to the interpretation thereof, shall be
 * governed by and construed under New York law as such law applies to
 * agreements between New York residents entered into and to be performed within
 * New York by two residents thereof and without reference to its conflict of
 * laws principles or the United Nations Conventions for the International Sale
 * of Goods. Except to the extent otherwise determined by Aviary, any action or
 * proceeding arising from or relating to this Agreement must be brought in a
 * federal court in the Southern District of New York or in state court in New
 * York County, New York, and each party irrevocably submits to the jurisdiction
 * and venue of any such court in any such action or proceeding. The prevailing
 * party in any action arising out of this Agreement shall be entitled to an
 * award of its costs and attorneys' fees. This Agreement may be amended only by
 * a writing executed by Aviary. If any provision of this Agreement is held to
 * be unenforceable for any reason, such provision shall be reformed only to the
 * extent necessary to make it enforceable. The failure of Aviary to act with
 * respect to a breach of this Agreement by Licensee or others does not
 * constitute a waiver and shall not limit Aviary's rights with respect to such
 * breach or any subsequent breaches. This Agreement is personal to Licensee and
 * may not be assigned or transferred for any reason whatsoever (including,
 * without limitation, by operation of law, merger, reorganization, or as a
 * result of an acquisition or change of control involving Licensee) without
 * Aviary's prior written consent and any action or conduct in violation of the
 * foregoing shall be void and without effect. Aviary expressly reserves the
 * right to assign this Agreement and to delegate any of its obligations
 * hereunder.
 * 
 * This is the entire and only material agreement on this matter between our
 * companies (unless we have another one, signed by both of us).
 * Any disputes on this agreement will be governed by NY law and NY courts.
 * While you are in town suing us, please do make sure to stop in a real NY deli
 * and get some pastrami and rye. It's delicious!
 * More discussion of where the court will be located. Like boyscouts, our motto
 * is "Always Be Prepared" and courts and wedding halls book up early this time
 * of year.
 * You sue us and we win, you're buying our attorneys a new Mercedes.
 * Even if you use white-out on your screen to erase some of this agreement, it
 * doesn't matter. Only Aviary can put the white-out on the screen.
 * If some of this agreement isn't legally valid, whatever remains if it will
 * hold strong.
 * If we don't respond quickly to your breaching this agreement, it doesn't mean
 * we can't do so in the future.
 * This agreement will always be between Aviary, Inc and you. You can't transfer
 * this agreement. If someone buys your product or company and plans to continue
 * using it, they will need to agree to these terms separately.
 * In the event that Aviary, Inc is sold or the API changes ownership, Aviary
 * will be able to transfer the API to a new owner without impacting our
 * agreement.
 * If some of this agreement isn't legally valid, whatever remains if it will
 * hold strong.
 * Last Updated September 15, 2011
 * 
 * It's a sunny, brisk day in NYC. We hope you're having a good day whenever you
 * read and agree to this! Please do drop us an email with any further questions
 * about this agreement to api@aviary.com and either way please do let us know
 * how you plan to use our API so we can promote you! Cheers, Avi
 */

package com.aviary.android.feather.sdk;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.Matrix;
import android.media.MediaScannerConnection;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.util.Pair;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.Window;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.aviary.android.feather.common.AviaryIntent;
import com.aviary.android.feather.common.log.LoggerFactory;
import com.aviary.android.feather.common.log.LoggerFactory.Logger;
import com.aviary.android.feather.common.log.LoggerFactory.LoggerType;
import com.aviary.android.feather.common.tracking.AviaryTracker;
import com.aviary.android.feather.common.utils.DateTimeUtils;
import com.aviary.android.feather.common.utils.IOUtils;
import com.aviary.android.feather.common.utils.SDKUtils;
import com.aviary.android.feather.common.utils.ScreenUtils;
import com.aviary.android.feather.common.utils.SystemUtils;
import com.aviary.android.feather.common.utils.os.AviaryAsyncTask;
import com.aviary.android.feather.headless.AviaryExecutionException;
import com.aviary.android.feather.headless.AviaryInitializationException;
import com.aviary.android.feather.headless.filters.NativeFilterProxy;
import com.aviary.android.feather.library.Constants;
import com.aviary.android.feather.library.MonitoredActivity;
import com.aviary.android.feather.library.content.ToolEntry;
import com.aviary.android.feather.library.filters.ToolLoaderFactory;
import com.aviary.android.feather.library.media.MediaUtils;
import com.aviary.android.feather.library.media.SingleMediaScannerItem;
import com.aviary.android.feather.library.services.HiResBackgroundService;
import com.aviary.android.feather.library.services.LocalDataService;
import com.aviary.android.feather.library.services.PreferenceService;
import com.aviary.android.feather.library.services.drag.DragLayer;
import com.aviary.android.feather.library.utils.BitmapUtils;
import com.aviary.android.feather.library.utils.ImageInfo;
import com.aviary.android.feather.library.utils.UIConfiguration;
import com.aviary.android.feather.sdk.AviaryMainController.FeatherContext;
import com.aviary.android.feather.sdk.AviaryMainController.OnBitmapChangeListener;
import com.aviary.android.feather.sdk.AviaryMainController.OnToolListener;
import com.aviary.android.feather.sdk.panels.AbstractPanel.ContentPanel;
import com.aviary.android.feather.sdk.panels.AbstractPanelLoaderService;
import com.aviary.android.feather.sdk.widget.AviaryBottomBarViewFlipper;
import com.aviary.android.feather.sdk.widget.AviaryBottomBarViewFlipper.OnBottomBarItemClickListener;
import com.aviary.android.feather.sdk.widget.AviaryImageRestoreSwitcher;
import com.aviary.android.feather.sdk.widget.AviaryImageRestoreSwitcher.OnRestoreStateListener;
import com.aviary.android.feather.sdk.widget.AviaryImageRestoreSwitcher.RestoreState;
import com.aviary.android.feather.sdk.widget.AviaryNavBarViewFlipper;
import com.aviary.android.feather.sdk.widget.AviaryNavBarViewFlipper.OnToolbarClickListener;
import com.aviary.android.feather.sdk.widget.AviaryToast;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import it.sephiroth.android.library.exif2.ExifInterface;
import it.sephiroth.android.library.exif2.ExifTag;
import it.sephiroth.android.library.imagezoom.ImageViewTouch;
import it.sephiroth.android.library.imagezoom.ImageViewTouchBase.DisplayType;
import it.sephiroth.android.library.imagezoom.graphics.IBitmapDrawable;
import it.sephiroth.android.library.widget.AdapterView;
import it.sephiroth.android.library.widget.AdapterView.OnItemClickListener;
import it.sephiroth.android.library.widget.HListView;

/**
 * FeatherActivity is the main activity controller.
 *
 * @author alessandro
 */
public class FeatherActivity extends MonitoredActivity
	implements OnToolbarClickListener, FeatherDownloadImageAsyncTask.OnImageDownloadListener, OnToolListener, FeatherContext, OnBitmapChangeListener, OnBottomBarItemClickListener, OnRestoreStateListener, OnItemClickListener {

	private static final int ALERT_CONFIRM_EXIT = 0;
	private static final int ALERT_DOWNLOAD_ERROR = 1;

	// TRACK: remove this!
	private static final int ALERT_REVERT_IMAGE = 2;
	private static final int ALERT_FEEDBACK = 3;
	private static final int ALERT_ABOUT = 4;
	private static final int ALERT_CONFIRM_EXIT_WITH_NO_CHANGES = 5;

	/** Describe the final action after save is completed */
	public static enum FinalAction {
		ASK, CLOSE
	}

	protected final Logger logger = LoggerFactory.getLogger("FeatherActivity", LoggerType.ConsoleLoggerType);

	/** SHA-1 version id. */
	@SuppressWarnings ("unused")
	public static final String ID = "$Id$";

	/** delay between click and panel opening */
	private static final int TOOLS_OPEN_DELAY_TIME = 50;

	private int pResultCode = RESULT_CANCELED;

	/** The main toolbar view. */
	private AviaryNavBarViewFlipper mToolbar;

	/** the main tools list view */
	private HListView mToolsList;

	/** The custom Toast used for modal loaders */
	private AviaryToast mToastLoader;

	/**
	 * The main drawing view container for tools implementing {@link ContentPanel}.
	 */
	private ViewGroup mDrawingViewContainer;

	/** inline progress loader. */
	private View mInlineProgressLoader;

	/** The main controller. */
	protected AviaryMainController mMainController;

	/** saving variable. */
	protected boolean mSaving;

	/** The current screen orientation. */
	private int mOrientation;

	/** The bottom bar view. */
	private AviaryBottomBarViewFlipper mBottomBarFlipper;

	/** default handler. */
	protected final Handler mHandler = new Handler();

	/** the popup container */
	private ViewGroup mPopupContainer;

	private DragLayer mDragLayer;

	/** Main image downloader task * */
	private FeatherDownloadImageAsyncTask mDownloadTask;

	/** The current Activity is visible and active */
	private boolean mIsRunning;

	private Handler mUIHandler = new Handler(new Handler.Callback() {

		@Override
		public boolean handleMessage(Message msg) {
			onStateChanged(msg.what, msg.arg1, msg.obj);
			return true;
		}
	});

	protected void onStateChanged(int new_state, int arg1, Object obj) {
		logger.info("onStateChanged: " + new_state);

		switch (new_state) {
			case AviaryMainController.STATE_OPENING:
				mToolbar.setClickable(false);
				break;

			case AviaryMainController.STATE_OPENED:
				mToolbar.setClickable(true);
				break;

			case AviaryMainController.STATE_CLOSING:
				mToolbar.setClickable(false);
				mImageRestore.setVisibility(View.VISIBLE);
				break;

			case AviaryMainController.STATE_CLOSED:
				mToolsList.setEnabled(true);
				mToolbar.setClickable(true);
				mToolbar.close();
				mToolbar.setSaveEnabled(true);
				// mToolsList.requestFocus();
				break;

			case AviaryMainController.STATE_DISABLED:

				mToolsList.setEnabled(false);
				mToolbar.setClickable(false);
				mToolbar.setSaveEnabled(false);
				break;

			case AviaryMainController.STATE_CONTENT_READY:
				mImageRestore.setVisibility(View.GONE);
				break;

			case AviaryMainController.STATE_READY:
				mToolbar.setTitle(mMainController.getActiveTool().labelResourceId, false);
				mToolbar.open();
				// once a tool panel has been opened, reset the main image view display
				// TODO: this is not correct
				getMainImage().resetMatrix();
				mImageRestore.clearStatus();
				break;

			case AviaryMainController.TOOLBAR_TITLE:
				mToolbar.setTitle((CharSequence) obj);
				break;

			case AviaryMainController.TOOLBAR_TITLE_INT:
				mToolbar.setTitle(arg1);
				break;

			case AviaryMainController.TOOLBAR_APPLY_VISIBILITY:
				mToolbar.setApplyVisible(arg1 == 0 ? false : true);
				break;
		}
	}

	private AviaryImageRestoreSwitcher mImageRestore;

	/**
	 * Override the internal setResult in order to register the internal close
	 * status.
	 *
	 * @param resultCode the result code
	 * @param data       the result data
	 */
	protected final void onSetResult(int resultCode, Intent data) {
		pResultCode = resultCode;

		if (null == data) {
			data = new Intent();
		}

		final Intent intent = getIntent();

		if (null != intent) {
			Bundle optional_bundle = intent.getBundleExtra(Constants.EXTRA_IN_EXTRAS);
			if (null != optional_bundle) {
				data.putExtra(Constants.EXTRA_IN_EXTRAS, optional_bundle);
			}

			if (null != mMainController && ! data.hasExtra(Constants.EXTRA_OUT_BITMAP_CHANGED)) {
				data.putExtra(Constants.EXTRA_OUT_BITMAP_CHANGED, mMainController.getBitmapIsChanged());
			}
		}

		setResult(resultCode, data);
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {

		long t1 = DateTimeUtils.tick();

		onPreCreate();

		super.onCreate(savedInstanceState);

		// if the device is not considered a tablet
		// let's disable the landascape orientation
		if (! ScreenUtils.isTablet(this)) {
			setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
		}

		setContentView(R.layout.aviary_main_view);

		onSetResult(RESULT_CANCELED, null);

		// Create the main Controller
		initializeController();

		onInitializeUtils();

		onInitializeUI();

		// initiate the filter manager
		mMainController.setOnToolListener(this);
		mMainController.setOnBitmapChangeListener(this);
		mMainController.setDragLayer(mDragLayer);

		// first check the validity of the incoming intent
		Uri srcUri = handleIntent(getIntent());

		if (srcUri == null) {
			onSetResult(RESULT_CANCELED, null);
			finish();
			return;
		}

		// download the requested image
		loadImage(srcUri);

		// calling post-create
		onPostCreate();

		logger.warn("total memory: %.2f", SystemUtils.getApplicationTotalMemory());
		getTracker().tagEvent("editor: opened");
		DateTimeUtils.tick(t1, "onCreate finished");
	}

	private void initializeController() {
		mMainController = new AviaryMainController(this, mUIHandler);
		onControllerLoaded(mMainController);
	}

	protected void onControllerLoaded(AviaryMainController controller) {}

	protected void onPostCreate() {}

	protected void onPreCreate() {}

	protected void onInitializeUtils() {
		try {
			NativeFilterProxy.init(this);
		} catch (AviaryInitializationException e) {
			e.printStackTrace();

			Toast.makeText(getApplicationContext(), "Sorry an error occurred: " + e.getMessage(), Toast.LENGTH_LONG).show();
			finish();
		}
	}

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		logger.info("onSaveInstanceState");
		super.onSaveInstanceState(outState);
	}

	@Override
	protected void onRestoreInstanceState(Bundle savedInstanceState) {
		logger.info("onRestoreInstanceState: " + savedInstanceState);
		super.onRestoreInstanceState(savedInstanceState);
	}

	@Override
	protected void onDestroy() {
		logger.info("onDestroy");

		if (pResultCode != RESULT_OK) getTracker().tagEvent("editor: cancelled");

		super.onDestroy();

		mToolbar.setOnToolbarClickListener(null);
		mBottomBarFlipper.setOnBottomBarItemClickListener(null);
		mMainController.setOnBitmapChangeListener(null);
		mMainController.setOnToolListener(null);

		if (null != mDownloadTask) {
			mDownloadTask.setOnLoadListener(null);
			mDownloadTask = null;
		}

		if (mMainController != null) {
			mMainController.dispose();
		}

		mUIHandler = null;
		mMainController = null;
	}

	/**
	 * Initialize varius UI elements.
	 */
	private void onInitializeUI() {
		// register the toolbar listeners
		mToolbar.setOnToolbarClickListener(this);

		// image view
		mImageRestore.getDefaultImageView().setDoubleTapEnabled(false);
		mImageRestore.getDefaultImageView().setDisplayType(DisplayType.FIT_IF_BIGGER);
		mImageRestore.getRestoredImageView().setDisplayType(DisplayType.FIT_IF_BIGGER);

		// initialize tools UI
		// mToolsList.setOverScrollMode( HListView.OVER_SCROLL_ALWAYS );
		mToolsList.setAdapter(null);

		mBottomBarFlipper.setOnBottomBarItemClickListener(this);

		LocalDataService service = mMainController.getService(LocalDataService.class);

		if (null != service && service.getIntentHasExtra(Constants.EXTRA_WHITELABEL)) {
			mBottomBarFlipper.toggleLogoVisibility(false);
		}
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		//@formatter:off

		Dialog dialog = null;

		switch (id) {
			case ALERT_CONFIRM_EXIT:
				dialog = new AlertDialog
					.Builder(this)
					.setTitle(R.string.feather_confirm)
					.setMessage(R.string.confirm_quit_message)
					.setPositiveButton(R.string.feather_yes_leave, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
							onBackPressed(true);
						}
					}).setNegativeButton(R.string.feather_keep_editing, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
						}
					}).create();
				break;

			case ALERT_DOWNLOAD_ERROR:
				dialog = new AlertDialog
					.Builder(this)
					.setTitle(R.string.feather_attention)
					.setMessage(R.string.feather_error_download_image_message)
					.setCancelable(false).setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
						@Override
						public void onClick(final DialogInterface dialog, final int which) {
							dialog.dismiss();
							finish();
						}
					}).create();
				break;

			case ALERT_REVERT_IMAGE:
				dialog = new AlertDialog
					.Builder(this)
					.setTitle(R.string.feather_revert_dialog_title)
					.setMessage(R.string.feather_revert_dialog_message)
					.setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
							onRevert();
						}
					}).setNegativeButton(android.R.string.no, new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
						}
					}).create();
				break;

			case ALERT_FEEDBACK:
				dialog = createFeedbackDialog();
				break;

			case ALERT_ABOUT:
				dialog = createAboutDialog();
				break;

			case ALERT_CONFIRM_EXIT_WITH_NO_CHANGES:
				dialog = new AlertDialog
					.Builder(this)
					.setTitle(R.string.feather_confirm)
					.setMessage(R.string.feather_unsaved_from_camera)
					.setPositiveButton(R.string.feather_yes_leave, new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
							onBackPressed(true);
						}
					}).setNegativeButton(R.string.feather_keep_editing, new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							dialog.dismiss();
						}
					}).create();
				break;
		}

		//@formatter:on
		return dialog;
	}

	protected Dialog createBaseDialog(int message, String buttonText, final OnClickListener button1Listener) {
		final Dialog dialog = new Dialog(FeatherActivity.this, R.style.AviaryTheme_Dialog_Custom);
		dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
		dialog.setContentView(R.layout.aviary_feedback_dialog_view);
		dialog.setCanceledOnTouchOutside(true);

		Window dialogWindow = dialog.getWindow();
		TextView textVersion = (TextView) dialogWindow.findViewById(R.id.aviary_version);
		TextView textMessage = (TextView) dialogWindow.findViewById(R.id.aviary_text);

		Button button1 = (Button) dialogWindow.findViewById(R.id.aviary_button1);
		Button button2 = (Button) dialogWindow.findViewById(R.id.aviary_button2);

		textVersion.setText(getString(R.string.feather_version) + " " + SDKUtils.SDK_VERSION_NAME);
		textMessage.setText(message);

		button1.setText(buttonText);
		button1.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				if (null != button1Listener) {
					button1Listener.onClick(v);
				}
				dialog.dismiss();
			}
		});

		button2.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				dialog.dismiss();
			}
		});

		return dialog;
	}

	/**
	 * Returns true if it's the first time the user
	 * opens the app
	 *
	 * @return
	 * @since 3.1.2
	 */
	public boolean isFirstTimeLaunch() {
		if (null != mMainController) {
			PreferenceService service = mMainController.getService(PreferenceService.class);
			if (null != service) {
				return service.isFirstTimeLaunch();
			}
		}
		return false;
	}

	/**
	 * Creates the About dialog
	 *
	 * @return
	 */
	protected Dialog createAboutDialog() {

		final OnClickListener listener = new OnClickListener() {

			@Override
			public void onClick(View v) {
				final Intent intent = new Intent(android.content.Intent.ACTION_VIEW);
				intent.setData(Uri.parse("http://www.aviary.com/android"));
				FeatherActivity.this.startActivity(intent);
			}
		};

		final Dialog dialog = createBaseDialog(R.string.feather_about_dialog_message, "aviary.com/android", listener);
		return dialog;
	}

	/**
	 * Creates the Feedback dialog
	 *
	 * @return
	 */
	protected Dialog createFeedbackDialog() {
		final OnClickListener listener = new OnClickListener() {

			@Override
			public void onClick(View v) {

				Intent intent = new Intent(Intent.ACTION_VIEW);
				intent.setData(Uri.parse("http://support.aviary.com/"));
				FeatherActivity.this.startActivity(intent);
			}
		};

		final Dialog dialog = createBaseDialog(R.string.feather_feedback_dialog_message, getString(R.string.feather_send_feedback), listener);
		return dialog;
	}

	/**
	 * Revert the original image.
	 */
	private void onRevert() {
		LocalDataService service = mMainController.getService(LocalDataService.class);
		loadImage(service.getSourceImageUri());
	}

	/**
	 * Manage the screen configuration change if the screen orientation has
	 * changed, notify the filter manager and reload the main workspace view.
	 *
	 * @param newConfig the new config
	 */

	@Override
	public void onConfigurationChanged(final Configuration newConfig) {

		super.onConfigurationChanged(newConfig);

		if (mOrientation != newConfig.orientation) {
			mOrientation = newConfig.orientation;

			if (null != mMainController) {
				mMainController.onConfigurationChanged(newConfig);
			}

		}
		mOrientation = newConfig.orientation;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		if (mSaving) return false;
		if (mMainController.getEnabled() && mMainController.isClosed()) {
			return true;
		}
		else {
			return false;
		}
	}

	@SuppressWarnings ("deprecation")
	@Override
	public void onBottomBarItemClick(int id) {
		if (id == R.id.aviary_white_logo) {
			showDialog(ALERT_ABOUT);
		}
	}

	/**
	 * Load an image using an async task.
	 *
	 * @param data
	 */
	protected void loadImage(Uri data) {
		if (null != mDownloadTask) {
			mDownloadTask.setOnLoadListener(null);
			mDownloadTask = null;
		}

		LocalDataService dataService = mMainController.getService(LocalDataService.class);

		int maxSize = dataService.getIntentExtra(Constants.EXTRA_IN_PREVIEW_MAX_SIZE, 0);

		dataService.setSourceImageUri(data);

		// if the tool list is not yet set
		List<String> toolList = null;
		if( mMainController.getToolList() == null) {
			if( dataService.getIntentHasExtra(Constants.EXTRA_TOOLS_LIST) ) {
				toolList = Arrays.asList(dataService.getIntentExtra(Constants.EXTRA_TOOLS_LIST, new String[]{}));
			}
		}

		// start the image download async task..
		mDownloadTask = new FeatherDownloadImageAsyncTask(data, maxSize, mMainController.getToolList() == null, toolList);
		mDownloadTask.setOnLoadListener(this);
		mDownloadTask.execute(this);
	}

	@Override
	public void onContentChanged() {
		super.onContentChanged();

		mDragLayer = (DragLayer) findViewById(R.id.dragLayer);

		mToolbar = (AviaryNavBarViewFlipper) findViewById(R.id.aviary_navbar);
		mBottomBarFlipper = (AviaryBottomBarViewFlipper) findViewById(R.id.aviary_bottombar);

		mToolsList = mBottomBarFlipper.getToolsListView();

		mDrawingViewContainer = (ViewGroup) findViewById(R.id.drawing_view_container);
		mInlineProgressLoader = findViewById(R.id.image_loading_view);

		mPopupContainer = (ViewGroup) findViewById(R.id.feather_dialogs_container);

		mBottomBarFlipper.setDisplayedChild(1);

		mImageRestore = (AviaryImageRestoreSwitcher) findViewById(R.id.aviary_restore);
	}

	@SuppressWarnings ("deprecation")
	@Override
	public void onBackPressed() {

		if (mToolbar.restored() || mImageRestore.getStatus() != RestoreState.None) {
			logger.log("Restore enabled, let's close that first!");
			mImageRestore.clearStatus();
			return;
		}

		if (! mMainController.onBackPressed()) {

			if (mToastLoader != null) mToastLoader.hide();

			if (mMainController.getBitmapIsChanged()) {

				LocalDataService dataService = mMainController.getService(LocalDataService.class);
				if( null != dataService && dataService.getIntentExtra(Constants.EXTRA_HIDE_EXIT_UNSAVE_CONFIRMATION, false) ) {
					super.onBackPressed();
				}
				else {
					showDialog(ALERT_CONFIRM_EXIT);
				}
			}
			else {
				if (! handleBackPressedOnUnchangedImage()) {
					onSetResult(RESULT_CANCELED, null);
					super.onBackPressed();
				}
			}
		}
	}

	/**
	 * Handle the back button when the image contains no modifications.
	 * If the source type was passed ( as for {@link com.aviary.android.feather.library.Constants#EXTRA_IN_SOURCE_TYPE}
	 * with the value of Constants.SourceType.Camera, then display the alert message because the original image was
	 * taken with the Camera and there's no guarantee that the original image was stored somewhere already.
	 *
	 * @return
	 */
	protected boolean handleBackPressedOnUnchangedImage() {
		final AviaryMainController controller = getMainController();
		if ( null != controller ) {
			LocalDataService service = getMainController().getService( LocalDataService.class );
			if ( null != service ) {
				if ( service.getIntentHasExtra(Constants.EXTRA_IN_SOURCE_TYPE) ) {
					String value = service.getIntentExtra(Constants.EXTRA_IN_SOURCE_TYPE, Constants.SourceType.Gallery.name());
					if ( Constants.SourceType.Camera.name().equals(value) ) {
						// ok show the alert message...
						showDialog(ALERT_CONFIRM_EXIT_WITH_NO_CHANGES);
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * Override the default behavior of back pressed
	 *
	 * @param force the super backpressed behavior
	 */
	protected void onBackPressed(boolean force) {
		if (force) super.onBackPressed();
		else onBackPressed();
	}

	/**
	 * Handles the original input Intent.
	 *
	 * @param intent
	 * @return the uri of the image to be loaded
	 */
	protected Uri handleIntent(Intent intent) {

		logger.info( "handleIntent" );

		if (intent != null && intent.getData() != null) {

			final String action = intent.getAction();
			HashMap<String, String> map = new HashMap<String, String>();
			map.put("from", null != action ? action : "null");
			getTracker().tagEventAttributes("editor: invoked", map);

			Uri data = intent.getData();

			if (SystemUtils.isIceCreamSandwich()) {
				if (data.toString().startsWith("content://com.android.gallery3d.provider")) {
					// use the com.google provider, not the com.android provider
					// ( for ICS only )
					data = Uri.parse(data.toString().replace("com.android.gallery3d", "com.google.android.gallery3d"));
				}
			}

			logger.log("src: " + data);
			return data;
		}
		return null;
	}

	protected List<String> loadStandaloneTools() {
		logger.info("loadStandaloneTools");
		return null;
	}

	Pair<List<String>, List<ToolEntry>> loadTools(List<String> currentList) {
		if (null == currentList) {
			currentList = loadStandaloneTools();

			if (null == currentList) {
				currentList = Arrays.asList(ToolLoaderFactory.getDefaultTools());
			}
		}

		List<ToolEntry> listEntries = new ArrayList<ToolEntry>();
		Map<String, ToolEntry> entryMap = new HashMap<String, ToolEntry>();
		ToolEntry[] all_entries = AbstractPanelLoaderService.getToolsEntries();

		for (int i = 0; i < all_entries.length; i++) {
			ToolLoaderFactory.Tools entry_name = all_entries[i].name;
			if (null != currentList && ! currentList.contains(entry_name.name())) continue;
			entryMap.put(entry_name.name(), all_entries[i]);
		}

		if (null != currentList) {
			for (String toolName : currentList) {
				if (! entryMap.containsKey(toolName)) continue;
				listEntries.add(entryMap.get(toolName));
			}
		}

		return new Pair<List<String>, List<ToolEntry>>(currentList, listEntries);
	}

	/**
	 * Return the current panel used to populate the active tool options.
	 *
	 * @return the options panel container
	 */
	@Override
	public ViewGroup getOptionsPanelContainer() {
		return mBottomBarFlipper.getContentPanel();
	}

	@Override
	public AviaryBottomBarViewFlipper getBottomBar() {
		return mBottomBarFlipper;
	}

	/**
	 * Return the main image view.
	 *
	 * @return the main image
	 */
	@Override
	public ImageViewTouch getMainImage() {
		return mImageRestore.getDefaultImageView();
	}

	@Override
	public AviaryTracker getTracker() {
		return mTracker;
	}

	/**
	 * Return the actual view used to populate a {@link ContentPanel}.
	 *
	 * @return the drawing image container
	 * @see {@link ContentPanel#getContentView(LayoutInflater)}
	 */
	@Override
	public ViewGroup getDrawingImageContainer() {
		return mDrawingViewContainer;
	}

	@Override
	public ViewGroup activatePopupContainer() {
		mPopupContainer.setVisibility(View.VISIBLE);
		return mPopupContainer;
	}

	@Override
	public void deactivatePopupContainer() {
		mPopupContainer.removeAllViews();
		mPopupContainer.setVisibility(View.GONE);
	}

	// ---------------------
	// Toolbar events
	// ---------------------

	@Override
	public void onRestoreClick() {
		logger.info("onRestoreClick");
		if (null != mMainController) {
			if (mMainController.getEnabled()) {

				getTracker().tagEvent("editor: image_reset");

				mMainController.onRestoreOriginal();
				mImageRestore.clearStatus();
			}
		}
	}

	/**
	 * User clicked on the Done button
	 * Start the save process
	 */
	@Override
	public void onDoneClick() {

		if (null != mMainController) {
			if (mMainController.getEnabled()) {

				LocalDataService dataService = mMainController.getService(LocalDataService.class);

				final boolean changed = mMainController.getBitmapIsChanged();
				final boolean saveWithNoChanges = dataService.getIntentExtra(Constants.EXTRA_IN_SAVE_ON_NO_CHANGES, true);

				if (LoggerFactory.LOG_ENABLED) {
					logger.log("bitmap changed: " + changed);
					logger.log("save with no changes: " + saveWithNoChanges);
				}

				// If the Image is not modified and the calling Intent
				// does not allow to save unmodified images, then return
				// a RESULT_CANCELED value
				if (! changed && ! saveWithNoChanges) {
					exitWithNoModifications();
					return;
				}

				mMainController.onSave();

				Bitmap bitmap = mMainController.getBitmap();
				if (bitmap != null) {
					performSave(bitmap, changed);
				}
			}
		}
	}

	/**
	 * Exit the Activity with a RESULT_CANCELED value and an extra
	 * value to indicate that no modifications were made to the image.
	 */
	protected void exitWithNoModifications() {
		logger.info("exitWithNoModifications");
		Intent result = new Intent();
		result.putExtra(Constants.EXTRA_OUT_BITMAP_CHANGED, false);
		onSetResult(RESULT_CANCELED, result);
		finish();
	}

	/**
	 * User clicked on the Apply button of a tool
	 * Apply the current tool modifications and update the main image
	 */
	@Override
	public void onApplyClick() {
		mMainController.onApply();
	}

	/**
	 * quick launch
	 * @param tool
	 * @param extras
	 */
	void quickLaunch(ToolLoaderFactory.Tools tool, Bundle extras) {
		logger.info("quickLaunch: %s", tool);
		AviaryMainController controller = getMainController();
		AbstractPanelLoaderService service = controller.getService(AbstractPanelLoaderService.class);

		ToolEntry entry = service.findEntry(tool);

		if (null != tool && controller.isClosed() && controller.getEnabled()) {
			controller.activateTool( entry, extras );
		}
	}

	/**
	 * Returns true if the activity was started requesting
	 * quick launch
	 *
	 * @return
	 */
	protected final boolean quickLaunchRequested() {
		final Intent intent = getIntent();
		return intent != null && intent.hasExtra(Constants.EXTRA_QUICK_LAUNCH_TOOL);
	}

	// --------------------------------
	// DownloadImageAsyncTask listener
	// --------------------------------

	/**
	 * List of tools loaded, we're ready to display them
	 */
	@Override
	public void onToolsLoaded(final List<String> toolNames, final List<ToolEntry> entries, final boolean whiteLabel) {
		logger.info("onToolsLoaded: %s, white-label: %b", toolNames, whiteLabel);

		LocalDataService data = mMainController.getService(LocalDataService.class);
		boolean white_label = whiteLabel && data.getIntentHasExtra(Constants.EXTRA_WHITELABEL);

		mToolsList.setAdapter(new ListAdapter(this, entries, white_label));
		mToolsList.setOnItemClickListener(this);

		mBottomBarFlipper.toggleLogoVisibility(! white_label);
		mMainController.setToolList(toolNames);
	}

	/**
	 * Local or remote image has been completely loaded. Now it's time to enable
	 * all the tools and fade in the image
	 *
	 * @param result    the result
	 * @param imageInfo
	 */

	@Override
	public void onDownloadComplete(final Bitmap result, final ImageInfo imageInfo) {

		logger.info("onDownloadComplete");

		logger.log("imageinfo: %s", imageInfo);

		mDownloadTask = null;

		getMainImage().setImageBitmap(result, null, - 1, UIConfiguration.IMAGE_VIEW_MAX_ZOOM);

		Animation animation = AnimationUtils.loadAnimation(FeatherActivity.this, android.R.anim.fade_in);
		animation.setFillEnabled(true);

		mImageRestore.setVisibility(View.VISIBLE);
		mImageRestore.startAnimation(animation);

		hideProgressLoader();


		if (mMainController != null) {
			if (! mMainController.getEnabled()) {
				mMainController.onActivate(result, imageInfo);
			}

			if (mMainController.getOriginalBitmap() != null) {
				mImageRestore.getRestoredImageView().setImageBitmap(mMainController.getOriginalBitmap(), null, - 1, UIConfiguration.IMAGE_VIEW_MAX_ZOOM);
				mImageRestore.setOnRestoreStateListener(FeatherActivity.this);
				mImageRestore.setRestoreEnabled(true);
			}
			else {
				mImageRestore.setRestoreEnabled(false);
				mImageRestore.setOnRestoreStateListener(null);
			}
		}

		if (null != result && null != imageInfo.getOriginalSize()) {
			logger.error("original.size: " + imageInfo.getOriginalSize()[0] + "x" + imageInfo.getOriginalSize()[1]);
			logger.error("final.size: " + result.getWidth() + "x" + result.getHeight());
		}

		// quick launch
		final Intent intent = getIntent();
		if (null != intent) {
			if (intent.hasExtra(Constants.EXTRA_QUICK_LAUNCH_TOOL)) {
				final ToolLoaderFactory.Tools tool = ToolLoaderFactory.findToolByName(intent.getStringExtra(Constants.EXTRA_QUICK_LAUNCH_TOOL));
				final Bundle tool_extras = intent.getBundleExtra(Constants.EXTRA_QUICK_LAUNCH_TOOL_OPTIONS);
				if (null != tool) {
					mHandler.post(new Runnable() {
						@Override
						public void run() {
							quickLaunch(tool, tool_extras);
						}
					});
				}
			}
		}

	}

	@SuppressWarnings ("deprecation")
	@Override
	public void onDownloadError(final String error) {
		logger.error("onDownloadError", error);
		mDownloadTask = null;
		hideProgressLoader();
		showDialog(ALERT_DOWNLOAD_ERROR);
	}



	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);
		mMainController.onActivityResult(requestCode, resultCode, data);
	}

	/**
	 * Hide progress loader.
	 */
	private void hideProgressLoader() {
		Animation fadeout = new AlphaAnimation(1, 0);
		fadeout.setDuration(getResources().getInteger(android.R.integer.config_mediumAnimTime));
		fadeout.setAnimationListener(new AnimationListener() {

			@Override
			public void onAnimationStart(Animation animation) {}

			@Override
			public void onAnimationRepeat(Animation animation) {}

			@Override
			public void onAnimationEnd(Animation animation) {
				mInlineProgressLoader.setVisibility(View.GONE);
			}
		});

		mInlineProgressLoader.startAnimation(fadeout);
	}

	@Override
	public void onDownloadStart() {
		mImageRestore.setVisibility(View.INVISIBLE);
		mInlineProgressLoader.setVisibility(View.VISIBLE);
	}

	// -------------------------------
	// Bitmap change listener
	// -------------------------------

	/**
	 * We have a new preview bitmap to display
	 * in the main ImageView
	 */
	@Override
	public void onPreviewChange(Bitmap bitmap, boolean reset) {

		boolean changed = true;

		if (! reset) {
			changed = BitmapUtils.compareBySize(((IBitmapDrawable) getMainImage().getDrawable()).getBitmap(), bitmap);
		}

		logger.info("onPreviewChange: " + bitmap + ", changed: " + changed);

		Matrix matrix = null;
		if (! changed) {
			matrix = getMainImage().getDisplayMatrix();
		}

		getMainImage().setImageBitmap(bitmap, matrix, - 1, UIConfiguration.IMAGE_VIEW_MAX_ZOOM);
		mImageRestore.clearStatus();
	}

	/**
	 * Invalidate the main ImageView
	 */
	@Override
	public void onInvalidateBitmap() {
		getMainImage().invalidate();
		mImageRestore.clearStatus();
	}

	/**
	 * Replace the current Bitmap with a new one
	 */
	@Override
	public void onBitmapChange(Bitmap bitmap, boolean update, Matrix matrix) {
		if (! update && matrix == null) {
			matrix = getMainImage().getDisplayMatrix();
		}
		getMainImage().setImageBitmap(bitmap, matrix, - 1, UIConfiguration.IMAGE_VIEW_MAX_ZOOM);
		mImageRestore.clearStatus();
	}

	;

	/**
	 * Perform save.
	 *
	 * @param bitmap the bitmap
	 */
	protected void performSave(final Bitmap bitmap, final boolean changed) {

		if (mSaving == true) return;
		mSaving = true;

		// send the tracking event
		getTracker().tagEvent("editor: saved", "tool_count", String.valueOf(mMainController.getToolCompleteCount()));

		// disable the controller while saving
		mMainController.setEnabled(false);

		LocalDataService service = mMainController.getService(LocalDataService.class);
//		List<EditToolVO> recipe = service.getRecipe();
//		if (null != recipe) {
//			for (EditToolVO item : recipe) {
//				logger.info("* recipe ( %s, %d )", item.getToolId(), item.getToolVersion());
//				for( ToolActionVO action : item.getToolActions() ) {
//					if(null != action.getPackIdentifier()) {
//						logger.log("-- packid: %s, contentid: %s", action.getPackIdentifier(), action.getContentIdentifier());
//					} else {
//						logger.log("-- value: %s", action.getValue());
//					}
//				}
//			}
//		}

		boolean requested_bitmap = service.getIntentExtra(Constants.EXTRA_RETURN_DATA, false);

		if (requested_bitmap) {
			// inline bitmap requested
			Bundle extras = new Bundle();
			extras.putParcelable("data", bitmap);
			onSetResult(RESULT_OK, new Intent().setData(service.getDestImageUri()).setAction("inline-data").putExtras(extras));
			finish();
		}
		else {
			HiResBackgroundService hiresService = mMainController.getService(HiResBackgroundService.class);
			boolean hires_enabled = hiresService.getHiresEnabled();

			// hi res is enabled, this means we received a system intent
			// or the partner did not provide an hi-res session id
			FinalAction action = FinalAction.ASK;

			if (AviaryIntent.ACTION_EDIT.equals(getIntent().getAction())) {
				action = FinalAction.CLOSE;
			}

			performSave(bitmap, service.getDestImageUri(), service.getOutputFormat(), service.getOutputQuality(), hires_enabled, action);
		}
	}

	protected void performSave(Bitmap bitmap, Uri saveUri, final CompressFormat outputFormat, int quality, boolean hires, FinalAction action) {
		logger.info("performSave, uri:%s, quality: %d, action:%s", saveUri, quality, action);

		File destFile;

		if (saveUri != null) {
			destFile = new File(saveUri.getPath());
		}
		else {
			destFile = getDefaultOutputDestination(outputFormat);
		}

		try {
			logger.log("trying to create the new file...");
			if (! destFile.exists()) {
				if (! destFile.createNewFile()) {
					logger.error("Failed to create the file");
				}
			}
		} catch (IOException e) {
			e.printStackTrace();
			try {
				logger.error("using a temporary file!");
				destFile = File.createTempFile("aviary-image-", ".jpeg");
			} catch (IOException e1) {
				e1.printStackTrace();
				// error here...
			}
		}

		LocalDataService service = getMainController().getService(LocalDataService.class);
		service.setDestImageUri(Uri.parse(destFile.getAbsolutePath()));

		SaveHiResImageTask mSaveTask = new SaveHiResImageTask(destFile, action, outputFormat, quality, hires);
		mSaveTask.execute(bitmap);
	}

	/**
	 * Application specific output file
	 *
	 * @param format
	 * @return
	 */
	protected File getDefaultOutputDestination(CompressFormat format) {
		return getSystemDefaultOutput(format);
	}

	/**
	 * Default system output folder for images
	 *
	 * @return
	 */
	protected File getSystemDefaultOutput(CompressFormat format) {
		return new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
		                "aviary-image-" + System.currentTimeMillis() + "." + (format == CompressFormat.JPEG ? "jpeg" : "png"));
	}

	/**
	 * Save the exif tags
	 *
	 * @param uri
	 */
	protected void saveExif(Uri uri) {
		logger.log("saveExif: " + uri);
		if (null != uri) {
			saveExif(uri.getPath());
		}
	}

	protected void saveExif(String path) {
		logger.log("saveExif: " + path);

		if (null == path) {
			return;
		}

		LocalDataService data = mMainController.getService(LocalDataService.class);
		ExifInterface newexif = new ExifInterface();

		if (null != data) {
			ImageInfo info = data.getImageInfo();
			if (null != info) {
				List<ExifTag> tags = info.getExifTagList();
				newexif.setTags(tags);
			}
		}

		newexif.deleteTag(ExifInterface.TAG_IMAGE_WIDTH);
		newexif.deleteTag(ExifInterface.TAG_IMAGE_LENGTH);
		newexif.setTag(newexif.buildTag(ExifInterface.TAG_ORIENTATION, 0));
		newexif.setTag(newexif.buildTag(ExifInterface.TAG_SOFTWARE, "Aviary for Android " + SDKUtils.SDK_VERSION_NAME));

		onSaveCustomTags(newexif);

		try {
			newexif.writeExif(path);
		} catch (Throwable e) {
			e.printStackTrace();
		}
	}

	protected void onSaveCustomTags(ExifInterface exif) {}

	@Override
	public void onToolCompleted() {}

	/**
	 * show the progress indicator in the toolbar content.
	 */
	@Override
	public void showToolProgress() {
		mToolbar.setApplyProgressVisible(true);
	}

	/**
	 * hide the progress indicator in the toolbar content reset to the first
	 * null state.
	 */
	@Override
	public void hideToolProgress() {
		mToolbar.setApplyProgressVisible(false);
	}

	@Override
	public void showModalProgress() {
		if (mToastLoader == null) {
			mToastLoader = com.aviary.android.feather.sdk.utils.UIUtils.createModalLoaderToast(this);
		}
		mToastLoader.show();
	}

	@Override
	public void hideModalProgress() {
		if (mToastLoader != null) {
			mToastLoader.hide();
		}
	}

	/**
	 * Gets the uI handler.
	 *
	 * @return the uI handler
	 */
	Handler getUIHandler() {
		return mUIHandler;
	}

	@Override
	public void onStart() {
		logger.info("onStart");
		super.onStart();
		mOrientation = getResources().getConfiguration().orientation; // getWindowManager().getDefaultDisplay().getRotation();
	}

	@Override
	public void onStop() {
		logger.info("onStop");
		super.onStop();
	}

	@Override
	protected void onRestart() {
		logger.info("onRestart");
		super.onRestart();
	}

	@Override
	protected void onResume() {
		super.onResume();
		mIsRunning = true;
	}

	@Override
	protected void onPause() {
		super.onPause();
		mIsRunning = false;
	}

	/**
	 * Current Activity is visible and active ( ie. within the {@link #onResume()} and the
	 * {@link #onPause()} methods )
	 *
	 * @return
	 */
	public boolean isActive() {
		return mIsRunning;
	}

	class ListAdapter extends ArrayAdapter<ToolEntry> {

		static final int TYPE_TOOL = 0;
		static final int TYPE_FEDDBACK = 1;

		Object mLock = new Object();
		LayoutInflater mInflater;
		List<ToolEntry> mObjects;
		int mViewWidth;
		int mToolViewWidth;
		boolean mWhiteLabel;

		public ListAdapter(Context context, List<ToolEntry> objects, boolean whiteLabel) {
			super(context, - 1);
			mViewWidth = context.getResources().getDisplayMetrics().widthPixels;
			mToolViewWidth = - 1;

			mInflater = LayoutInflater.from(context);
			mObjects = objects;
			mWhiteLabel = whiteLabel;
		}

		@Override
		public int getViewTypeCount() {
			if (mWhiteLabel) return 1;
			return 2;
		}

		@Override
		public int getItemViewType(int position) {
			if (mWhiteLabel) return TYPE_TOOL;
			return position == (getCount() - 1) ? TYPE_FEDDBACK : TYPE_TOOL;
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			final int type = getItemViewType(position);

			if (null == convertView) {
				if (type == TYPE_TOOL) {

					convertView = mInflater.inflate(R.layout.aviary_tool_layout, parent, false);
					LayoutParams params = convertView.getLayoutParams();

					if (mToolViewWidth == - 1) {
						int[] sizes = mToolsList.measureChild(convertView);
						double numberOfItems = Math.floor((double) mViewWidth / sizes[0]) + 0.5;
						mToolViewWidth = (int) ((double) mViewWidth / numberOfItems);
					}

					if (null != params) {
						params.width = mToolViewWidth;
						convertView.setLayoutParams(params);
					}

				}
				else {
					convertView = mInflater.inflate(R.layout.aviary_tool_feedback_layout, parent, false);
				}
			}

			if (type == TYPE_TOOL) {
				final ToolEntry item = getItem(position);
				convertView.setTag(item);
			}
			return convertView;
		}

		@Override
		public ToolEntry getItem(int position) {
			return mObjects.get(position);
		}

		@Override
		public int getCount() {
			if (mWhiteLabel) return mObjects.size();
			return mObjects.size() + 1;
		}

		@Override
		public long getItemId(int position) {
			return 0;
		}
	}

	/**
	 * Returns the main controller
	 *
	 * @return
	 */
	public AviaryMainController getMainController() {
		return mMainController;
	}

	@SuppressWarnings ("deprecation")
	@Override
	public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
		logger.info("onItemClick: " + position);

		if (null != view && parent.isEnabled() && parent.getAdapter() != null) {
			int type = parent.getAdapter().getItemViewType(position);

			if (type == ListAdapter.TYPE_TOOL) {
				// tool
				final Object tag = parent.getAdapter().getItem(position);

				if (tag instanceof ToolEntry) {
					mUIHandler.postDelayed(new Runnable() {

						@Override
						public void run() {
							// mark the badge for this tool as read
							// ( (AviaryBadgeToolLayout) view ).markAsRead();

							mMainController.activateTool((ToolEntry) tag);
						}
					}, TOOLS_OPEN_DELAY_TIME);
				}
			}
			else if (type == ListAdapter.TYPE_FEDDBACK) {
				// feedback
				showDialog(ALERT_FEEDBACK);
			}
		}
	}

	// ------------------------------
	// Restore original image methods
	// ------------------------------

	@Override
	public boolean onRestoreBegin() {
		logger.info("onRestoreBegin");

		if (null != mMainController) {
			if (null != mMainController.getOriginalBitmap()) {
				if (! mMainController.getPanelIsRendering() && mMainController.getBitmapIsChangedOrChanging()) {
					mImageRestore.setDisplayedChild(1);
					getTracker().tagEvent("editor: original_shown");
					return true;
				}
			}
		}

		return false;
	}

	@Override
	public void onRestoreChanged() {
		logger.info("onRestoreChanged");

		mToolbar.toggleRestore(true);
		getTracker().tagEvent("editor: restore_original_shown");
		// nothing...
	}

	@Override
	public void onRestoreEnd() {
		logger.info("onRestoreEnd");
		mImageRestore.setDisplayedChild(0);
		mToolbar.toggleRestore(false);
	}


	// ---------------------
	// Save image task
	// ---------------------

	/**
	 * Error saving the image, display an error message
	 * to the user
	 *
	 * @param message
	 */
	protected void onSaveError(String message) {
		onSetResult(RESULT_CANCELED, null);

		new AlertDialog
			.Builder(this)
			.setTitle(R.string.feather_generic_error_title)
			.setMessage(message)
			.setCancelable(false)
			.setOnCancelListener(
				new DialogInterface.OnCancelListener() {
					@Override
					public void onCancel(final DialogInterface dialog) {
						onSetResult(RESULT_CANCELED, null);
						finish();
					}
				}
			)
			.setPositiveButton(
				R.string.feather_close, new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						onSetResult(RESULT_CANCELED, null);
						finish();
					}
				}
			).show();
	}

	/**
	 * Save process completed. Ask the user if he wants to see the result or just close
	 * the app
	 *
	 * @param output
	 */
	protected void onSaveCompleted(final Pair<String, Uri> output, final FinalAction action) {
		logger.info("onSaveCompleted: " + output + ", action: " + action);

		final Intent intent = new Intent();

		if(null != output){
			intent.setData(Uri.parse(output.first));
			intent.putExtra(AviaryIntent.EXTRA_OUTPUT_URI, output.second);
		}

		onSetResult(RESULT_OK, intent);
		finish();
	}

	/**
	 * Save Hi-Res image
	 *
	 * @author alessandro
	 */
	class SaveHiResImageTask extends AviaryAsyncTask<Bitmap, Integer, Pair<String, Uri>>
		implements HiResBackgroundService.OnHiresListener, DialogInterface.OnDismissListener, MediaScannerConnection.OnScanCompletedListener, SingleMediaScannerItem.OnScanErrorListener {

		File mDestFile;
		Bitmap mBitmap;
		ProgressDialog mProgress;
		AviaryExecutionException mHiresException;
		FinalAction mFinalAction;
		CompressFormat mCompressFormat;
		private int mCompressQuality;
		boolean mIsHiRes;
		String mErrorString;
		private Object mFinishedLock = new Object();
		private Object mScanCompletedLock = new Object();

		Logger logger = LoggerFactory.getLogger("SaveHiResImageTask", LoggerType.ConsoleLoggerType);

		/** result of mediascanner */
		private Uri mOutputContentUri;

		public SaveHiResImageTask(final File file, final FinalAction action, final CompressFormat format, int compressQuality, final boolean hires) {
			logger.info("ctor, file: %s, action: %s, hires: %b", file.getAbsolutePath(), action, hires);
			mFinalAction = action;
			mDestFile = file;
			mIsHiRes = hires;
			mCompressFormat = format;
			mCompressQuality = compressQuality;
		}

		@Override
		protected void PreExecute() {
			logger.info("PreExecute");
			mProgress = new ProgressDialog(FeatherActivity.this);
			mProgress.setIndeterminate(true);
			mProgress.setProgressStyle(ProgressDialog.STYLE_SPINNER);
			mProgress.setCancelable(true);
			mProgress.setCanceledOnTouchOutside(false);
			mProgress.setOnDismissListener(this);
			mProgress.setMessage(getString(R.string.feather_save_progress));
			mProgress.show();
		}

		@Override
		protected void onCancelled() {
			logger.error("save task cancelled");
			onSetResult(RESULT_CANCELED, null);
			finish();
		}

		@Override
		public void onDismiss(DialogInterface dialog) {
			logger.error("onDismiss");
			this.cancel(true);
		}

		@Override
		protected void ProgressUpdate(Integer... values) {
			int index = values[0];
			int total = values[1];
			logger.info("ProgressUpdate. %d/%d", index, total);

			String message;

			if (index == 1) message = getString(R.string.feather_loading_image);
			else if (index == total) message = getString(R.string.feather_save_progress);
			else message = "Applying action " + (index - 1) + " of " + (total - 2);
			mProgress.setMessage(message);
		}

		@Override
		protected Pair<String, Uri> doInBackground(Bitmap... params) {
			final Bitmap bitmap = params[0];
			mBitmap = bitmap;

			boolean result;
			if (mIsHiRes) {
				result = saveInBackgroundHiRes();
			}
			else {
				result = saveInBackgroundLowRes();
			}

			if (isCancelled()) {
				return null;
			}

			if (result && mDestFile != null && (mErrorString == null && mHiresException == null)) {

				// insert image into database gallery
				try {
					MediaUtils.insertImage(FeatherActivity.this, mDestFile);
				} catch (IllegalStateException e) {
					e.printStackTrace();
					mErrorString = e.getMessage();
					return null;
				}

				// save EXIF tags here
				saveExif(mDestFile.getAbsolutePath());

				// call the MediaScanner to scan for new file
				SingleMediaScannerItem mScanner = new SingleMediaScannerItem(FeatherActivity.this, mDestFile, this, this);
				mScanner.run();

				synchronized (mScanCompletedLock) {
					try {
						mScanCompletedLock.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
						mErrorString = e.getMessage();
						return null;
					}
				}
				return Pair.create(mDestFile.getAbsolutePath(), mOutputContentUri);
			}
			return null;
		}

		/**
		 * Save the hi-res image
		 *
		 * @return
		 */
		private boolean saveInBackgroundHiRes() {
			logger.info("saveInBackgroundHiRes");

			HiResBackgroundService service = mMainController.getService(HiResBackgroundService.class);
			if (null == service) return false;

			// register to the hires listener list
			mMainController.addOnHiresListener(this);

			// request save
			service.save(mDestFile.getAbsolutePath(), mCompressFormat, mCompressQuality);

			logger.log("waiting for notification from mFinishedLock..");
			synchronized (mFinishedLock) {
				logger.log("waiting for mFinishedLock...");
				try {
					mFinishedLock.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
					mMainController.removeOnHiresListener(this);
					return false;
				}
			}

			mMainController.removeOnHiresListener(this);
			return true;
		}

		/**
		 * Save the low-res image
		 *
		 * @return
		 */
		private boolean saveInBackgroundLowRes() {
			logger.info("saveInBackgroundLowRes");
			try {
				OutputStream output_stream = new FileOutputStream(mDestFile);
				mBitmap.compress(mCompressFormat, mCompressQuality, output_stream);
				IOUtils.closeSilently(output_stream);
				return true;
			} catch (IOException e) {
				logger.error(e.getMessage());
				mErrorString = e.getMessage();
				e.printStackTrace();
				return false;
			}
		}

		@Override
		protected void PostExecute(Pair<String, Uri> result) {
			logger.info("PostExecute, mErrorString:%s, mHiResException: %s", mErrorString, mHiresException);

			// hide the progress dialog
			try {
				if (mProgress.getWindow() != null) {
					mProgress.dismiss();
				}
			} catch (Throwable t) {
				// what??
				t.printStackTrace();
				logger.error(t.getMessage());
			}

			// if was cancelled just finish
			if (isCancelled()) {
				logger.warn("was cancelled..");
				onSetResult(RESULT_CANCELED, null);
				finish();
				return;
			}

			if (null != mHiresException || null != mErrorString || result == null) {

				// we had an hi-res exception, so let's try to save lo-res image
				if (mHiresException != null) {
					performSave(mBitmap, null, mCompressFormat, mCompressQuality, false, mFinalAction);
					return;
				}
				onSaveError(mErrorString != null ? mErrorString : getString(R.string.feather_error_saving_image));
			}
			else {
				// ok, got a result, everything was fine
				onSaveCompleted(result, mFinalAction);
			}
		}

		@Override
		public void onHiresError(AviaryExecutionException ex) {
			logger.info("onHiresError: %s", ex);

			mHiresException = ex;
			synchronized (mFinishedLock) {
				mFinishedLock.notify();
			}
		}

		@Override
		public void onHiresProgress(int index, int total) {
			publishProgress(index, total);
		}

		@Override
		public void onHiresComplete() {
			logger.log("onHiresComplete");

			synchronized (mFinishedLock) {
				mFinishedLock.notify();
			}
		}

		@Override
		public void onScanCompleted(String path, Uri uri) {
			logger.info("onScanCompleted: " + path + ", uri: " + uri);
			mOutputContentUri = uri;
			synchronized (mScanCompletedLock) {
				mScanCompletedLock.notify();
			}
		}

		@Override
		public void OnScanError() {
			logger.error("onScanError");
			synchronized (mScanCompletedLock) {
				mScanCompletedLock.notify();
			}
		}

	}
}
